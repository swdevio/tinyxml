<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>TiXmlNode Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jul 19 21:00:18 2001 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>tinyxml.h</h1>This is the verbatim text of the tinyxml.h include file.<div class="fragment"><pre>/*
Copyright (c) 2000 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied 
warranty. In no event will the authors be held liable for any 
damages arising from the use of this software.

Permission is granted to anyone to use this software for any 
purpose, including commercial applications, and to alter it and 
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must 
not claim that you wrote the original software. If you use this 
software in a product, an acknowledgment in the product documentation 
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and 
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source 
distribution.
*/


#ifndef TINYXML_INCLUDED
#define TINYXML_INCLUDED

#pragma warning( disable : 4530 )
#pragma warning( disable : 4786 )

#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

class <a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a>;
class <a class="code" href="class_TiXmlElement.html">TiXmlElement</a>;
class <a class="code" href="class_TiXmlComment.html">TiXmlComment</a>;
class <a class="code" href="class_TiXmlUnknown.html">TiXmlUnknown</a>;
class <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>;
class <a class="code" href="class_TiXmlText.html">TiXmlText</a>;
class <a class="code" href="class_TiXmlDeclaration.html">TiXmlDeclaration</a>;


class <a class="code" href="class_TiXmlBase.html">TiXmlBase</a>
{
    friend class <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>;
    friend class <a class="code" href="class_TiXmlElement.html">TiXmlElement</a>;
    friend class <a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a>;
 
  public:
    TiXmlBase()                             {}  
    virtual ~TiXmlBase()                    {}
    
    /*  All TinyXml classes can print themselves to a filestream.
    */
    virtual void Print( FILE* fp, int depth )   = 0;
  
  protected:
    /*  General parsing helper method. Takes a pointer in,
        skips all the white space it finds, and returns a pointer
        to the first non-whitespace data.
    */
    static const char* SkipWhiteSpace( const char* p );

    /*  Reads an XML name into the string provided. Returns
        a pointer just past the last character of the name, 
        or 0 if the function has an error.
    */
    static const char* ReadName( const char* p, std::string* name );

    enum
    {
        NO_ERROR = 0,
        ERROR_OPENING_FILE,
        ERROR_OUT_OF_MEMORY,
        ERROR_PARSING_ELEMENT,
        ERROR_FAILED_TO_READ_ELEMENT_NAME,
        ERROR_READING_ELEMENT_VALUE,
        ERROR_READING_ATTRIBUTES,
        ERROR_PARSING_EMPTY,
        ERROR_READING_END_TAG,
        ERROR_PARSING_UNKNOWN,
        ERROR_PARSING_COMMENT,
        ERROR_PARSING_DECLARATION,

        ERROR_STRING_COUNT
    };
    static const char* errorString[ ERROR_STRING_COUNT ];
};


class <a class="code" href="class_TiXmlNode.html">TiXmlNode</a> : public <a class="code" href="class_TiXmlBase.html">TiXmlBase</a>
{
  public:
    enum NodeType 
    {
        DOCUMENT, ELEMENT, COMMENT, UNKNOWN, TEXT, DECLARATION, TYPECOUNT
    };

    virtual ~TiXmlNode();

    const std::string&amp; <a class="code" href="class_TiXmlNode.html#a1">Value</a>()  const           { return value; }

    void <a class="code" href="class_TiXmlNode.html#a2">SetValue</a>( const std::string&amp; _value )      { value = _value; }

    void <a class="code" href="class_TiXmlNode.html#a3">Clear</a>();

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a4">Parent</a>() const                   { return parent; }

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a5">FirstChild</a>() const   { return firstChild; }      
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a5">FirstChild</a>( const std::string&amp; value ) const;    
    
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a8">LastChild</a>() const    { return lastChild; }       
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a8">LastChild</a>( const std::string&amp; value ) const;     

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a9">IterateChildren</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* previous );

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a9">IterateChildren</a>( const std::string&amp; value, <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* previous );
        
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a11">InsertEndChild</a>( const <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>&amp; addThis );                  

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a12">InsertBeforeChild</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* beforeThis, const <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>&amp; addThis );

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a13">InsertAfterChild</a>(  <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* afterThis, const <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>&amp; addThis );
    
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a14">ReplaceChild</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* replaceThis, const <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>&amp; withThis );
    
    bool <a class="code" href="class_TiXmlNode.html#a15">RemoveChild</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* removeThis );

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a16">PreviousSibling</a>() const          { return prev; }

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a16">PreviousSibling</a>( const std::string&amp; ) const;
    
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a18">NextSibling</a>() const              { return next; }

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* <a class="code" href="class_TiXmlNode.html#a18">NextSibling</a>( const std::string&amp; ) const;

    <a class="code" href="class_TiXmlElement.html">TiXmlElement</a>* <a class="code" href="class_TiXmlNode.html#a20">NextSiblingElement</a>() const;

    <a class="code" href="class_TiXmlElement.html">TiXmlElement</a>* <a class="code" href="class_TiXmlNode.html#a20">NextSiblingElement</a>( const std::string&amp; ) const;

    <a class="code" href="class_TiXmlElement.html">TiXmlElement</a>* <a class="code" href="class_TiXmlNode.html#a22">FirstChildElement</a>()   const;
    
    <a class="code" href="class_TiXmlElement.html">TiXmlElement</a>* <a class="code" href="class_TiXmlNode.html#a22">FirstChildElement</a>( const std::string&amp; value ) const;

    virtual int <a class="code" href="class_TiXmlNode.html#a24">Type</a>()  { return type; }

    <a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a>* <a class="code" href="class_TiXmlNode.html#a25">GetDocument</a>() const;

    <a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a>* <a class="code" href="class_TiXmlNode.html#a26">ToDocument</a>() const   { return ( type == DOCUMENT ) ? (<a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a>*) this : 0; } 
    <a class="code" href="class_TiXmlElement.html">TiXmlElement</a>*  <a class="code" href="class_TiXmlNode.html#a27">ToElement</a>() const    { return ( type == ELEMENT  ) ? (<a class="code" href="class_TiXmlElement.html">TiXmlElement</a>*)  this : 0; } 
    <a class="code" href="class_TiXmlComment.html">TiXmlComment</a>*  <a class="code" href="class_TiXmlNode.html#a28">ToComment</a>() const    { return ( type == COMMENT  ) ? (<a class="code" href="class_TiXmlComment.html">TiXmlComment</a>*)  this : 0; } 
    <a class="code" href="class_TiXmlUnknown.html">TiXmlUnknown</a>*  <a class="code" href="class_TiXmlNode.html#a29">ToUnknown</a>() const    { return ( type == UNKNOWN  ) ? (<a class="code" href="class_TiXmlUnknown.html">TiXmlUnknown</a>*)  this : 0; } 
    <a class="code" href="class_TiXmlText.html">TiXmlText</a>*     <a class="code" href="class_TiXmlNode.html#a30">ToText</a>()    const    { return ( type == TEXT     ) ? (<a class="code" href="class_TiXmlText.html">TiXmlText</a>*)     this : 0; } 
    <a class="code" href="class_TiXmlDeclaration.html">TiXmlDeclaration</a>* <a class="code" href="class_TiXmlNode.html#a31">ToDeclaration</a>() const { return ( type == DECLARATION ) ? (<a class="code" href="class_TiXmlDeclaration.html">TiXmlDeclaration</a>*) this : 0; } 

    virtual <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* Clone() const = 0;

  protected:
    TiXmlNode( NodeType type );
    virtual const char* Parse( const char* ) = 0;

    // The node is passed in by ownership. This object will delete it.
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* LinkEndChild( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* addThis );

    // Figure out what is at *p, and parse it. Return a node if
    // successful, and update p.
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* IdentifyAndParse( const char** p );

    void CopyToClone( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* target ) const { target-&gt;value = value; }

    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>*      parent;     
    NodeType        type;
    
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>*      firstChild;
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>*      lastChild;

    std::string     value;
    
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>*      prev;
    <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>*      next;
};


class <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a> : public <a class="code" href="class_TiXmlBase.html">TiXmlBase</a>
{
    friend class TiXmlAttributeSet;

  public:
    <a class="code" href="class_TiXmlAttribute.html#a0">TiXmlAttribute</a>() : prev( 0 ), next( 0 ) {}

    <a class="code" href="class_TiXmlAttribute.html#a0">TiXmlAttribute</a>( const std::string&amp; _name, const std::string&amp; _value )   : name( _name ), value( _value ), prev( 0 ), next( 0 ) {}

    const std::string&amp; <a class="code" href="class_TiXmlAttribute.html#a2">Name</a>()  const { return name; }       
    const std::string&amp; <a class="code" href="class_TiXmlAttribute.html#a3">Value</a>() const { return value; }      

    void <a class="code" href="class_TiXmlAttribute.html#a4">SetName</a>( const std::string&amp; _name )    { name = _name; }       
    void <a class="code" href="class_TiXmlAttribute.html#a5">SetValue</a>( const std::string&amp; _value )  { value = _value; }     

    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="class_TiXmlAttribute.html#a6">Next</a>();
    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="class_TiXmlAttribute.html#a7">Previous</a>();

    bool operator==( const <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>&amp; rhs ) const { return rhs.name == name; }
    bool operator&lt;( const <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>&amp; rhs )  const { return name &lt; rhs.name; }
    bool operator&gt;( const <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>&amp; rhs )  const { return name &gt; rhs.name; }

    /*  [internal use] 
        Attribtue parsing starts: first letter of the name
                         returns: the next char after the value end quote
    */  
    const char* Parse( const char* );

    // [internal use] 
    virtual void Print( FILE* fp, int depth );

    // [internal use]
    // Set the document pointer so the attribute can report errors.
    void SetDocument( <a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a>* doc )  { document = doc; }

  private:
    <a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a>*  document;   // A pointer back to a document, for error reporting.
    std::string     name;
    std::string     value;

    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* prev;
    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* next;
};


/*  A class used to manage a group of attributes.
    It is only used internally, both by the ELEMENT and the DECLARATION.
    
    The set can be changed transparent to the Element and Declaration
    classes that use it, but NOT transparent to the Attribute 
    which has to implement a next() and previous() method. Which makes
    it a bit problematic and prevents the use of STL.

    This version is implemented with circular lists because:
        - I like circular lists
        - it demonstrates some independence from the (typical) doubly linked list.
*/
class TiXmlAttributeSet
{
  public:
    TiXmlAttributeSet();
    ~TiXmlAttributeSet();

    void Add( <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* attribute );
    void Remove( <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* attribute );

    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* First() const   { return ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* Last()  const   { return ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
    
    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* Find( const std::string&amp; name ) const;

  private:
    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a> sentinel;
};


class <a class="code" href="class_TiXmlElement.html">TiXmlElement</a> : public <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>
{
  public:
    <a class="code" href="class_TiXmlElement.html#a0">TiXmlElement</a>( const std::string&amp; value );

    virtual ~TiXmlElement();

    const std::string* <a class="code" href="class_TiXmlElement.html#a2">Attribute</a>( const std::string&amp; name ) const;

    const std::string* <a class="code" href="class_TiXmlElement.html#a2">Attribute</a>( const std::string&amp; name, int* i ) const;

    void <a class="code" href="class_TiXmlElement.html#a4">SetAttribute</a>( const std::string&amp; name, 
                       const std::string&amp; value );

    void <a class="code" href="class_TiXmlElement.html#a4">SetAttribute</a>( const std::string&amp; name, 
                       int value );

    void <a class="code" href="class_TiXmlElement.html#a6">RemoveAttribute</a>( const std::string&amp; name );

    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="class_TiXmlElement.html#a7">FirstAttribute</a>()    { return attributeSet.<a class="code" href="class_TiXmlAttributeSet.html#a4">First</a>(); }        
    <a class="code" href="class_TiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="class_TiXmlElement.html#a8">LastAttribute</a>()     { return attributeSet.<a class="code" href="class_TiXmlAttributeSet.html#a5">Last</a>(); }     

    // [internal use] Creates a new Element and returs it.
    virtual <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* Clone() const;
    // [internal use] 
    virtual void Print( FILE* fp, int depth );

  protected:
    /*  [internal use] 
        Attribtue parsing starts: next char past '&lt;'
                         returns: next char past '&gt;'
    */  
    virtual const char* Parse( const char* );
    const char* ReadValue( const char* p );

  private:
    TiXmlAttributeSet attributeSet;
};


class <a class="code" href="class_TiXmlComment.html">TiXmlComment</a> : public <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>
{
  public:
    <a class="code" href="class_TiXmlComment.html#a0">TiXmlComment</a>() : <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>::COMMENT ) {}
    virtual ~TiXmlComment() {}

    // [internal use] Creates a new Element and returs it.
    virtual <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* Clone() const;
    // [internal use] 
    virtual void Print( FILE* fp, int depth );

  protected:
    /*  [internal use] 
        Attribtue parsing starts: at the ! of the !--
                         returns: next char past '&gt;'
    */  
    virtual const char* Parse( const char* );
};


class <a class="code" href="class_TiXmlText.html">TiXmlText</a> : public <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>
{
  public:
    TiXmlText()  : <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>::TEXT ) {}
    virtual ~TiXmlText() {}


    // [internal use] Creates a new Element and returns it.
    virtual <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* Clone() const;
    // [internal use] 
    virtual void Print( FILE* fp, int depth );
    // [internal use]   
    bool Blank();   // returns true if all white space and new lines

    /*  [internal use] 
        Attribtue parsing starts: First char of the text
                         returns: next char past '&gt;'
    */  
    virtual const char* Parse( const char* );
};


class <a class="code" href="class_TiXmlDeclaration.html">TiXmlDeclaration</a> : public <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>
{
  public:
    <a class="code" href="class_TiXmlDeclaration.html#a0">TiXmlDeclaration</a>()   : <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>::DECLARATION ) {}

    <a class="code" href="class_TiXmlDeclaration.html#a0">TiXmlDeclaration</a>( const std::string&amp; version, 
                      const std::string&amp; encoding,
                      const std::string&amp; standalone );

    virtual ~TiXmlDeclaration() {}

    const std::string&amp; <a class="code" href="class_TiXmlDeclaration.html#a3">Version</a>()        { return version; }
    const std::string&amp; <a class="code" href="class_TiXmlDeclaration.html#a4">Encoding</a>()       { return encoding; }
    const std::string&amp; <a class="code" href="class_TiXmlDeclaration.html#a5">Standalone</a>()     { return standalone; }

    // [internal use] Creates a new Element and returs it.
    virtual <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* Clone() const;
    // [internal use] 
    virtual void Print( FILE* fp, int depth );

  protected:
    //  [internal use] 
    //  Attribtue parsing starts: next char past '&lt;'
    //                   returns: next char past '&gt;'
    
    virtual const char* Parse( const char* );

  private:
    std::string version;
    std::string encoding;
    std::string standalone;
};


class <a class="code" href="class_TiXmlUnknown.html">TiXmlUnknown</a> : public <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>
{
  public:
    TiXmlUnknown() : <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>( <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>::UNKNOWN ) {}
    virtual ~TiXmlUnknown() {}

    // [internal use]   
    virtual <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* Clone() const;
    // [internal use]   
    virtual void Print( FILE* fp, int depth );

  protected:
    /*  [internal use] 
        Attribute parsing starts: First char of the text
                         returns: next char past '&gt;'
    */  
    virtual const char* Parse( const char* );
};


class <a class="code" href="class_TiXmlDocument.html">TiXmlDocument</a> : public <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>
{
  public:
    <a class="code" href="class_TiXmlDocument.html#a0">TiXmlDocument</a>();
    <a class="code" href="class_TiXmlDocument.html#a0">TiXmlDocument</a>( const std::string&amp; documentName );
    
    virtual ~TiXmlDocument() {}

    bool <a class="code" href="class_TiXmlDocument.html#a3">LoadFile</a>();
    bool <a class="code" href="class_TiXmlDocument.html#a4">SaveFile</a>();
    bool <a class="code" href="class_TiXmlDocument.html#a3">LoadFile</a>( const std::string&amp; filename );
    bool <a class="code" href="class_TiXmlDocument.html#a4">SaveFile</a>( const std::string&amp; filename );

    const char* <a class="code" href="class_TiXmlDocument.html#a7">Parse</a>( const char* );
    
    bool <a class="code" href="class_TiXmlDocument.html#a8">Error</a>()                        { return error; }
    const std::string&amp; <a class="code" href="class_TiXmlDocument.html#a9">ErrorDesc</a>()      { return errorDesc; }

    virtual void <a class="code" href="class_TiXmlDocument.html#a11">Print</a>( FILE* fp, int depth = 0 );
    void <a class="code" href="class_TiXmlDocument.html#a11">Print</a>()                                        { <a class="code" href="class_TiXmlDocument.html#a11">Print</a>( stdout, 0 ); }
  
    // [internal use]   
    virtual <a class="code" href="class_TiXmlNode.html">TiXmlNode</a>* Clone() const;
    // [internal use]   
    void SetError( int err ) {      assert( err &gt; 0 &amp;&amp; err &lt; ERROR_STRING_COUNT );
                                    error   = true; 
                                    errorId = err;
                                    errorDesc = errorString[ errorId ]; }

  private:
    bool error;
    int  errorId;   
    std::string errorDesc;
};


#endif

</div></pre><hr><address><small>Generated at Thu Jul 19 21:00:18 2001 for TinyXml by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

